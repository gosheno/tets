// GetAveragePriceNoCache —á–∏—Ç–∞–µ—Ç –∞–¥—Ä–µ—Å–∞ –∏–∑ —Ñ–∞–π–ª–∞ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ä–µ–¥–Ω—é—é —Ü–µ–Ω—É –≤—Å–µ—Ö NFT –±–µ–∑ –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è
package botutils

import (
	"bufio"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"strconv"
	apiqueue "tg-getgems-bot/api"
	"time"

	"github.com/go-redis/redis/v8"
	"golang.org/x/sync/singleflight"
)

const (
	apiKey          = "1759093403351-mainnet-9508047-r-Rodf2lVdSIS22ecj6daQcNQTSZLiGTJmmrfJi0Xo2gdppFPU"
	baseURL         = "https://api.getgems.io/public-api/v1/nft/history/"
	defaultPrice    = 1.4
	requestInterval = 770 * time.Millisecond
)


type Response struct {
	Response struct {
		Items []Item `json:"items"`
	} `json:"response"`
	Success bool `json:"success"`
}

type Item struct {
	TypeData struct {
		Type  string `json:"type"`
		Price string `json:"price,omitempty"`
	} `json:"typeData"`
}

// –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ—Å–ª–µ–¥–Ω–µ–π —Ü–µ–Ω—ã –ø–æ –∞–¥—Ä–µ—Å—É NFT —Å –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º
func getLastPrice(address string) float64 {
	url := fmt.Sprintf("%s%s?limit=1&types=mint&types=sold", baseURL, address)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		log.Println("‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–ø—Ä–æ—Å–∞:", err)
		return defaultPrice
	}
	req.Header.Add("accept", "application/json")
	req.Header.Add("Authorization", apiKey)

	resp, err := apiqueue.Queue.Enqueue(req, apiqueue.Low)
	if err != nil {
		log.Println("‚ùå –û—à–∏–±–∫–∞ HTTP-–∑–∞–ø—Ä–æ—Å–∞:", err)
		return defaultPrice
	}
	defer resp.Body.Close()

	var result Response
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		log.Println("‚ùå –û—à–∏–±–∫–∞ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è JSON:", err)
		return defaultPrice
	}

	if len(result.Response.Items) == 0 {
		log.Printf("‚ö†Ô∏è –ù–µ—Ç –∏—Å—Ç–æ—Ä–∏–∏ –¥–ª—è NFT %s, –∏—Å–ø–æ–ª—å–∑—É–µ–º defaultPrice %.2f\n", address, defaultPrice)
		return defaultPrice
	}

	lastItem := result.Response.Items[0]
	var price float64
	switch lastItem.TypeData.Type {
	case "sold":
		price, err = strconv.ParseFloat(lastItem.TypeData.Price, 64)
		if err != nil || price <= 0 {
			log.Printf("‚ö†Ô∏è –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Ü–µ–Ω–∞ –¥–ª—è NFT %s, –∏—Å–ø–æ–ª—å–∑—É–µ–º defaultPrice %.2f\n", address, defaultPrice)
			price = defaultPrice
		}
	case "mint":
		price = defaultPrice
	default:
		log.Printf("‚ö†Ô∏è –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ '%s' –¥–ª—è NFT %s, –∏—Å–ø–æ–ª—å–∑—É–µ–º defaultPrice %.2f\n",
			lastItem.TypeData.Type, address, defaultPrice)
		price = defaultPrice
	}
	return price
}

// GetAveragePrice —á–∏—Ç–∞–µ—Ç –∞–¥—Ä–µ—Å–∞ –∏–∑ —Ñ–∞–π–ª–∞ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ä–µ–¥–Ω—é—é —Ü–µ–Ω—É –≤—Å–µ—Ö NFT —Å –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º
func GetAveragePrice(redisClient *redis.Client, sendProgress func(text string)) (float64, bool) {
	cacheKey := "nft_avg_price"
	cached, err := GetValue(redisClient, cacheKey)
	sendProgress("—â–∞ —á–µ–∫–Ω—É")
	time.Sleep(1 * time.Second) // –ù–µ–±–æ–ª—å—à–∞—è –ø–∞—É–∑–∞ –¥–ª—è UX
	if err == nil && cached != "" {
		price, err := strconv.ParseFloat(cached, 64)
		if err == nil {
			fmt.Println("[Redis] –í–æ–∑–≤—Ä–∞—Ç –∏–∑ –∫–µ—à–∞ —Å—Ä–µ–¥–Ω–µ–π —Ü–µ–Ω—ã:", price)
			return price, true
		}
	}
	return GetAveragePriceNoCache(redisClient, sendProgress)
}

var requestGroup singleflight.Group
func GetAveragePriceNoCache(redisClient *redis.Client, sendProgress func(text string)) (float64, bool) {
    cacheKey := "nft_avg_price"
    file, err := os.Open("nft_addresses.txt")
    sendProgress("üìä –ù–∞—á–∏–Ω–∞—é —Å—á–∏—Ç—ã–≤–∞—Ç—å –∞–¥—Ä–µ—Å–∞...")

    if err != nil {
        log.Println("‚ùå –û—à–∏–±–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è —Ñ–∞–π–ª–∞:", err)
        sendProgress("–û—à–∏–±–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è —Ñ–∞–π–ª–∞ –∞–¥—Ä–µ—Å–æ–≤")
        return defaultPrice, false
    }
    defer file.Close()

    scanner := bufio.NewScanner(file)

    // –ü–æ–¥—Å—á—ë—Ç –æ–±—â–µ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Å—Ç—Ä–æ–∫
    var total int
    for scanner.Scan() {
        total++
    }
    if err := scanner.Err(); err != nil {
        log.Println("‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞:", err)
        return defaultPrice, false
    }

    // –°–±—Ä–æ—Å —Å–∫–∞–Ω–µ—Ä–∞
    file.Seek(0, 0)
    scanner = bufio.NewScanner(file)

    ticker := time.NewTicker(requestInterval)
    defer ticker.Stop()

    var sum float64
    var count int

    log.Printf("üìä –û–±—Ä–∞–±–æ—Ç–∫–∞ NFT –Ω–∞—á–∞—Ç–∞")

    sem := make(chan struct{}, 1) // –º–∞–∫—Å–∏–º—É–º 5 –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤

    for scanner.Scan() {
        address := scanner.Text()

        addrCacheKey := fmt.Sprintf("nft_price:%s", address)
        cachedPrice, err := redisClient.Get(Ctx, addrCacheKey).Result()
        var lastPrice float64
        if err == nil {
			fmt.Print("[cache] ", address, "\n")
            lastPrice, _ = strconv.ParseFloat(cachedPrice, 64)
        } else {
            // –ó–∞–ø—Ä–æ—Å —á–µ—Ä–µ–∑ singleflight + semaphore
            val, _, _ := requestGroup.Do(addrCacheKey, func() (interface{}, error) {
                sem <- struct{}{}          // –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞
                defer func() { <-sem }()   // –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ
                <-ticker.C                  // –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏
                lastPrice := getLastPrice(address)
				fmt.Print("[api] ", address, "\n")
                redisClient.Set(Ctx, addrCacheKey, fmt.Sprintf("%f", lastPrice), time.Hour)
                return lastPrice, nil
            })
            lastPrice = val.(float64)
        }

        sum += lastPrice
        count++
		if count == 10 {
			break
		}
        // –ü—Ä–æ–≥—Ä–µ—Å—Å –∫–∞–∂–¥—ã–µ 10 –∏–ª–∏ –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–π NFT
        if count%10 == 0 || count == total {
            msg := fmt.Sprintf("üìä –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ %d –∏–∑ %d NFT", count, total)
            sendProgress(msg)
            log.Printf("üìä –ü—Ä–æ–≥—Ä–µ—Å—Å: %d/%d, —Ç–µ–∫—É—â–∞—è —Å—Ä–µ–¥–Ω—è—è: %.2f TON", count, total, sum/float64(count))
        }
    }

    if err := scanner.Err(); err != nil {
        log.Println("‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞:", err)
        return defaultPrice, false
    }

    avgPrice := sum / float64(count)
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ä–µ–¥–Ω—é—é —Ü–µ–Ω—É –≤ –∫—ç—à
    err = redisClient.Set(Ctx, cacheKey, fmt.Sprintf("%f", avgPrice), time.Hour*10).Err()
    if err != nil {
        log.Println("‚ùå –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —Å—Ä–µ–¥–Ω–µ–π —Ü–µ–Ω—ã –≤ Redis:", err)
    }

    sendProgress("üìä –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞")
    time.Sleep(1 * time.Second)
    return avgPrice, true
}